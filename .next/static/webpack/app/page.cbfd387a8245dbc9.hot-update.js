"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/lib/api.ts":
/*!************************!*\
  !*** ./src/lib/api.ts ***!
  \************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   checkHealth: function() { return /* binding */ checkHealth; },\n/* harmony export */   getChatResponse: function() { return /* binding */ getChatResponse; },\n/* harmony export */   getModels: function() { return /* binding */ getModels; },\n/* harmony export */   improvePrompt: function() { return /* binding */ improvePrompt; },\n/* harmony export */   improvePromptText: function() { return /* binding */ improvePromptText; },\n/* harmony export */   localImprovePrompt: function() { return /* binding */ localImprovePrompt; }\n/* harmony export */ });\n// API client for interacting with the AI gateway\n// Base URL for the API\nconst API_BASE_URL = \"https://secret-ai-gateway.onrender.com\";\n// Function to get available models\nasync function getModels() {\n    try {\n        const response = await fetch(\"\".concat(API_BASE_URL, \"/api/models\"), {\n            headers: {\n                \"X-API-Key\": \"bWFzdGVyQHNjcnRsYWJzLmNvbTpTZWNyZXROZXR3b3JrTWFzdGVyS2V5X18yMDI1\"\n            }\n        });\n        if (!response.ok) {\n            throw new Error(\"Failed to fetch models: \".concat(response.status));\n        }\n        return await response.json();\n    } catch (error) {\n        console.error(\"Error fetching models:\", error);\n        return {\n            models: [\n                \"deepseek-r1:70b\",\n                \"llama3.2-vision\"\n            ]\n        }; // Fallback\n    }\n}\n// Function to check API health\nasync function checkHealth() {\n    try {\n        const response = await fetch(\"\".concat(API_BASE_URL, \"/api/health\"), {\n            headers: {\n                \"X-API-Key\": \"bWFzdGVyQHNjcnRsYWJzLmNvbTpTZWNyZXROZXR3b3JrTWFzdGVyS2V5X18yMDI1\"\n            }\n        });\n        return response.ok;\n    } catch (error) {\n        console.error(\"Health check failed:\", error);\n        return false;\n    }\n}\n// Function to get chat response\nasync function getChatResponse(prompt) {\n    let model = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"deepseek-r1:70b\";\n    try {\n        const response = await fetch(\"\".concat(API_BASE_URL, \"/api/chat?prompt=\").concat(encodeURIComponent(prompt), \"&model=\").concat(model), {\n            method: \"GET\",\n            headers: {\n                Accept: \"application/json\",\n                \"X-API-Key\": \"bWFzdGVyQHNjcnRsYWJzLmNvbTpTZWNyZXROZXR3b3JrTWFzdGVyS2V5X18yMDI1\"\n            }\n        });\n        if (!response.ok) {\n            throw new Error(\"Chat API error: \".concat(response.status));\n        }\n        const data = await response.json();\n        return data;\n    } catch (error) {\n        console.error(\"Error getting chat response:\", error);\n        throw error;\n    }\n}\n// Local fallback function to improve prompts if the API fails\nfunction localImprovePrompt(prompt) {\n    // Simple improvements\n    let improved = prompt;\n    // Add specificity\n    if (prompt.length < 20) {\n        improved = \"\".concat(prompt, \" with detailed examples and step-by-step instructions\");\n    }\n    // Add clarity for vague prompts\n    if (!prompt.includes(\"?\") && prompt.split(\" \").length < 5) {\n        improved = \"Please provide a comprehensive explanation about \".concat(prompt);\n    }\n    // Add structure for longer prompts\n    if (prompt.length > 50 && !prompt.includes(\"1.\") && !prompt.includes(\"First\")) {\n        improved = \"\".concat(prompt, \"\\n\\nPlease structure your response with:\\n1. Introduction\\n2. Main points\\n3. Examples\\n4. Conclusion\");\n    }\n    // If we didn't make any improvements, add a generic enhancement\n    if (improved === prompt) {\n        improved = \"\".concat(prompt, \"\\n\\nPlease provide a detailed, well-structured response with examples where appropriate.\");\n    }\n    return improved;\n}\n// Function to improve a prompt using the new GET endpoint\nasync function improvePromptText(prompt) {\n    let target = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"text\";\n    try {\n        const response = await fetch(\"\".concat(API_BASE_URL, \"/api/improve-prompt?prompt=\").concat(encodeURIComponent(prompt), \"&target=\").concat(target), {\n            method: \"GET\",\n            headers: {\n                Accept: \"application/json\"\n            }\n        });\n        if (!response.ok) {\n            const errorText = await response.text();\n            console.error(\"Improve prompt API error: \".concat(response.status), errorText);\n            return localImprovePrompt(prompt);\n        }\n        const result = await response.json();\n        // Handle the response format: { \"response\": \"<improved prompt>\" }\n        if (result && result.response) {\n            return result.response;\n        }\n        // Fallback to local improvement if response format is unexpected\n        return localImprovePrompt(prompt);\n    } catch (error) {\n        console.error(\"Error improving prompt:\", error);\n        return localImprovePrompt(prompt);\n    }\n}\nasync function improvePrompt(prompt) {\n    try {\n        // The API expects a string as the body, not a JSON object\n        const response = await fetch(\"\".concat(API_BASE_URL, \"/api/improve-prompt\"), {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"text/plain\",\n                Accept: \"application/json\"\n            },\n            // Send the prompt as a plain string, not a JSON object\n            body: prompt\n        });\n        if (!response.ok) {\n            // Log more details about the error\n            const errorText = await response.text();\n            console.error(\"Improve prompt API error: \".concat(response.status), errorText);\n            // If the API fails, use our local improvement function\n            console.log(\"Using local prompt improvement fallback\");\n            return localImprovePrompt(prompt);\n        }\n        const result = await response.json();\n        // If the API returns the same prompt or an empty result, use our local improvement\n        if (!result || typeof result === \"string\" && (result.trim() === prompt.trim() || result.trim() === \"\") || typeof result === \"object\" && (!result.Response || result.Response.trim() === prompt.trim())) {\n            console.log(\"API returned unchanged prompt, using local improvement\");\n            return localImprovePrompt(prompt);\n        }\n        return result;\n    } catch (error) {\n        console.error(\"Error improving prompt:\", error);\n        // Use local improvement as fallback\n        return localImprovePrompt(prompt);\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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SUFBSSxPQUFPLEVBQUMsS0FDdkQsT0FBT0osV0FBVyxZQUNqQixFQUFDQSxPQUFPSyxRQUFRLElBQUlMLE9BQU9LLFFBQVEsQ0FBQ0QsSUFBSSxPQUFPbkIsT0FBT21CLElBQUksRUFBQyxHQUM1RDtZQUNEdkIsUUFBUXNCLEdBQUcsQ0FBQztZQUNaLE9BQU9aLG1CQUFtQk47UUFDM0I7UUFFQSxPQUFPZTtJQUNSLEVBQUUsT0FBT3BCLE9BQU87UUFDZkMsUUFBUUQsS0FBSyxDQUFDLDJCQUEyQkE7UUFDekMsb0NBQW9DO1FBQ3BDLE9BQU9XLG1CQUFtQk47SUFDM0I7QUFDRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvbGliL2FwaS50cz8yZmFiIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEFQSSBjbGllbnQgZm9yIGludGVyYWN0aW5nIHdpdGggdGhlIEFJIGdhdGV3YXlcclxuXHJcbi8vIEJhc2UgVVJMIGZvciB0aGUgQVBJXHJcbmNvbnN0IEFQSV9CQVNFX1VSTCA9IFwiaHR0cHM6Ly9zZWNyZXQtYWktZ2F0ZXdheS5vbnJlbmRlci5jb21cIjtcclxuXHJcbi8vIEF2YWlsYWJsZSBtb2RlbHNcclxuZXhwb3J0IHR5cGUgQUlNb2RlbCA9IFwiZGVlcHNlZWstcjE6NzBiXCIgfCBcImxsYW1hMy4yLXZpc2lvblwiO1xyXG5cclxuLy8gRnVuY3Rpb24gdG8gZ2V0IGF2YWlsYWJsZSBtb2RlbHNcclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldE1vZGVscygpIHtcclxuXHR0cnkge1xyXG5cdFx0Y29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtBUElfQkFTRV9VUkx9L2FwaS9tb2RlbHNgLCB7XHJcblx0XHRcdGhlYWRlcnM6IHtcclxuXHRcdFx0XHRcIlgtQVBJLUtleVwiOiBcImJXRnpkR1Z5UUhOamNuUnNZV0p6TG1OdmJUcFRaV055WlhST1pYUjNiM0pyVFdGemRHVnlTMlY1WDE4eU1ESTFcIlxyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHRcdGlmICghcmVzcG9uc2Uub2spIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZmV0Y2ggbW9kZWxzOiAke3Jlc3BvbnNlLnN0YXR1c31gKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcblx0fSBjYXRjaCAoZXJyb3IpIHtcclxuXHRcdGNvbnNvbGUuZXJyb3IoXCJFcnJvciBmZXRjaGluZyBtb2RlbHM6XCIsIGVycm9yKTtcclxuXHRcdHJldHVybiB7IG1vZGVsczogW1wiZGVlcHNlZWstcjE6NzBiXCIsIFwibGxhbWEzLjItdmlzaW9uXCJdIH07IC8vIEZhbGxiYWNrXHJcblx0fVxyXG59XHJcblxyXG4vLyBGdW5jdGlvbiB0byBjaGVjayBBUEkgaGVhbHRoXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjaGVja0hlYWx0aCgpIHtcclxuXHR0cnkge1xyXG5cdFx0Y29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtBUElfQkFTRV9VUkx9L2FwaS9oZWFsdGhgLCB7XHJcblx0XHRcdGhlYWRlcnM6IHtcclxuXHRcdFx0XHRcIlgtQVBJLUtleVwiOiBcImJXRnpkR1Z5UUhOamNuUnNZV0p6TG1OdmJUcFRaV055WlhST1pYUjNiM0pyVFdGemRHVnlTMlY1WDE4eU1ESTFcIlxyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHRcdHJldHVybiByZXNwb25zZS5vaztcclxuXHR9IGNhdGNoIChlcnJvcikge1xyXG5cdFx0Y29uc29sZS5lcnJvcihcIkhlYWx0aCBjaGVjayBmYWlsZWQ6XCIsIGVycm9yKTtcclxuXHRcdHJldHVybiBmYWxzZTtcclxuXHR9XHJcbn1cclxuXHJcbi8vIEZ1bmN0aW9uIHRvIGdldCBjaGF0IHJlc3BvbnNlXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRDaGF0UmVzcG9uc2UoXHJcblx0cHJvbXB0OiBzdHJpbmcsXHJcblx0bW9kZWw6IEFJTW9kZWwgPSBcImRlZXBzZWVrLXIxOjcwYlwiXHJcbikge1xyXG5cdHRyeSB7XHJcblx0XHRjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKFxyXG5cdFx0XHRgJHtBUElfQkFTRV9VUkx9L2FwaS9jaGF0P3Byb21wdD0ke2VuY29kZVVSSUNvbXBvbmVudChcclxuXHRcdFx0XHRwcm9tcHRcclxuXHRcdFx0KX0mbW9kZWw9JHttb2RlbH1gLFxyXG5cdFx0XHR7XHJcblx0XHRcdFx0bWV0aG9kOiBcIkdFVFwiLFxyXG5cdFx0XHRcdGhlYWRlcnM6IHtcclxuXHRcdFx0XHRcdEFjY2VwdDogXCJhcHBsaWNhdGlvbi9qc29uXCIsXHJcblx0XHRcdFx0XHRcIlgtQVBJLUtleVwiOiBcImJXRnpkR1Z5UUhOamNuUnNZV0p6TG1OdmJUcFRaV055WlhST1pYUjNiM0pyVFdGemRHVnlTMlY1WDE4eU1ESTFcIlxyXG5cdFx0XHRcdH0sXHJcblx0XHRcdH1cclxuXHRcdCk7XHJcblxyXG5cdFx0aWYgKCFyZXNwb25zZS5vaykge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoYENoYXQgQVBJIGVycm9yOiAke3Jlc3BvbnNlLnN0YXR1c31gKTtcclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG5cdFx0cmV0dXJuIGRhdGE7XHJcblx0fSBjYXRjaCAoZXJyb3IpIHtcclxuXHRcdGNvbnNvbGUuZXJyb3IoXCJFcnJvciBnZXR0aW5nIGNoYXQgcmVzcG9uc2U6XCIsIGVycm9yKTtcclxuXHRcdHRocm93IGVycm9yO1xyXG5cdH1cclxufVxyXG5cclxuLy8gTG9jYWwgZmFsbGJhY2sgZnVuY3Rpb24gdG8gaW1wcm92ZSBwcm9tcHRzIGlmIHRoZSBBUEkgZmFpbHNcclxuZXhwb3J0IGZ1bmN0aW9uIGxvY2FsSW1wcm92ZVByb21wdChwcm9tcHQ6IHN0cmluZyk6IHN0cmluZyB7XHJcblx0Ly8gU2ltcGxlIGltcHJvdmVtZW50c1xyXG5cdGxldCBpbXByb3ZlZCA9IHByb21wdDtcclxuXHJcblx0Ly8gQWRkIHNwZWNpZmljaXR5XHJcblx0aWYgKHByb21wdC5sZW5ndGggPCAyMCkge1xyXG5cdFx0aW1wcm92ZWQgPSBgJHtwcm9tcHR9IHdpdGggZGV0YWlsZWQgZXhhbXBsZXMgYW5kIHN0ZXAtYnktc3RlcCBpbnN0cnVjdGlvbnNgO1xyXG5cdH1cclxuXHJcblx0Ly8gQWRkIGNsYXJpdHkgZm9yIHZhZ3VlIHByb21wdHNcclxuXHRpZiAoIXByb21wdC5pbmNsdWRlcyhcIj9cIikgJiYgcHJvbXB0LnNwbGl0KFwiIFwiKS5sZW5ndGggPCA1KSB7XHJcblx0XHRpbXByb3ZlZCA9IGBQbGVhc2UgcHJvdmlkZSBhIGNvbXByZWhlbnNpdmUgZXhwbGFuYXRpb24gYWJvdXQgJHtwcm9tcHR9YDtcclxuXHR9XHJcblxyXG5cdC8vIEFkZCBzdHJ1Y3R1cmUgZm9yIGxvbmdlciBwcm9tcHRzXHJcblx0aWYgKFxyXG5cdFx0cHJvbXB0Lmxlbmd0aCA+IDUwICYmXHJcblx0XHQhcHJvbXB0LmluY2x1ZGVzKFwiMS5cIikgJiZcclxuXHRcdCFwcm9tcHQuaW5jbHVkZXMoXCJGaXJzdFwiKVxyXG5cdCkge1xyXG5cdFx0aW1wcm92ZWQgPSBgJHtwcm9tcHR9XFxuXFxuUGxlYXNlIHN0cnVjdHVyZSB5b3VyIHJlc3BvbnNlIHdpdGg6XFxuMS4gSW50cm9kdWN0aW9uXFxuMi4gTWFpbiBwb2ludHNcXG4zLiBFeGFtcGxlc1xcbjQuIENvbmNsdXNpb25gO1xyXG5cdH1cclxuXHJcblx0Ly8gSWYgd2UgZGlkbid0IG1ha2UgYW55IGltcHJvdmVtZW50cywgYWRkIGEgZ2VuZXJpYyBlbmhhbmNlbWVudFxyXG5cdGlmIChpbXByb3ZlZCA9PT0gcHJvbXB0KSB7XHJcblx0XHRpbXByb3ZlZCA9IGAke3Byb21wdH1cXG5cXG5QbGVhc2UgcHJvdmlkZSBhIGRldGFpbGVkLCB3ZWxsLXN0cnVjdHVyZWQgcmVzcG9uc2Ugd2l0aCBleGFtcGxlcyB3aGVyZSBhcHByb3ByaWF0ZS5gO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIGltcHJvdmVkO1xyXG59XHJcblxyXG4vLyBGdW5jdGlvbiB0byBpbXByb3ZlIGEgcHJvbXB0IHVzaW5nIHRoZSBuZXcgR0VUIGVuZHBvaW50XHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBpbXByb3ZlUHJvbXB0VGV4dChwcm9tcHQ6IHN0cmluZywgdGFyZ2V0OiAndGV4dCcgfCAnaW1hZ2UnID0gJ3RleHQnKSB7XHJcblx0dHJ5IHtcclxuXHRcdGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goXHJcblx0XHRcdGAke0FQSV9CQVNFX1VSTH0vYXBpL2ltcHJvdmUtcHJvbXB0P3Byb21wdD0ke2VuY29kZVVSSUNvbXBvbmVudChwcm9tcHQpfSZ0YXJnZXQ9JHt0YXJnZXR9YCxcclxuXHRcdFx0e1xyXG5cdFx0XHRcdG1ldGhvZDogXCJHRVRcIixcclxuXHRcdFx0XHRoZWFkZXJzOiB7XHJcblx0XHRcdFx0XHRBY2NlcHQ6IFwiYXBwbGljYXRpb24vanNvblwiLFxyXG5cdFx0XHRcdH0sXHJcblx0XHRcdH1cclxuXHRcdCk7XHJcblxyXG5cdFx0aWYgKCFyZXNwb25zZS5vaykge1xyXG5cdFx0XHRjb25zdCBlcnJvclRleHQgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XHJcblx0XHRcdGNvbnNvbGUuZXJyb3IoYEltcHJvdmUgcHJvbXB0IEFQSSBlcnJvcjogJHtyZXNwb25zZS5zdGF0dXN9YCwgZXJyb3JUZXh0KTtcclxuXHRcdFx0cmV0dXJuIGxvY2FsSW1wcm92ZVByb21wdChwcm9tcHQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuXHRcdFxyXG5cdFx0Ly8gSGFuZGxlIHRoZSByZXNwb25zZSBmb3JtYXQ6IHsgXCJyZXNwb25zZVwiOiBcIjxpbXByb3ZlZCBwcm9tcHQ+XCIgfVxyXG5cdFx0aWYgKHJlc3VsdCAmJiByZXN1bHQucmVzcG9uc2UpIHtcclxuXHRcdFx0cmV0dXJuIHJlc3VsdC5yZXNwb25zZTtcclxuXHRcdH1cclxuXHRcdFxyXG5cdFx0Ly8gRmFsbGJhY2sgdG8gbG9jYWwgaW1wcm92ZW1lbnQgaWYgcmVzcG9uc2UgZm9ybWF0IGlzIHVuZXhwZWN0ZWRcclxuXHRcdHJldHVybiBsb2NhbEltcHJvdmVQcm9tcHQocHJvbXB0KTtcclxuXHR9IGNhdGNoIChlcnJvcikge1xyXG5cdFx0Y29uc29sZS5lcnJvcihcIkVycm9yIGltcHJvdmluZyBwcm9tcHQ6XCIsIGVycm9yKTtcclxuXHRcdHJldHVybiBsb2NhbEltcHJvdmVQcm9tcHQocHJvbXB0KTtcclxuXHR9XHJcbn1cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGltcHJvdmVQcm9tcHQocHJvbXB0OiBzdHJpbmcpIHtcclxuXHR0cnkge1xyXG5cdFx0Ly8gVGhlIEFQSSBleHBlY3RzIGEgc3RyaW5nIGFzIHRoZSBib2R5LCBub3QgYSBKU09OIG9iamVjdFxyXG5cdFx0Y29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtBUElfQkFTRV9VUkx9L2FwaS9pbXByb3ZlLXByb21wdGAsIHtcclxuXHRcdFx0bWV0aG9kOiBcIlBPU1RcIixcclxuXHRcdFx0aGVhZGVyczoge1xyXG5cdFx0XHRcdFwiQ29udGVudC1UeXBlXCI6IFwidGV4dC9wbGFpblwiLCAvLyBDaGFuZ2VkIGZyb20gYXBwbGljYXRpb24vanNvblxyXG5cdFx0XHRcdEFjY2VwdDogXCJhcHBsaWNhdGlvbi9qc29uXCIsXHJcblx0XHRcdH0sXHJcblx0XHRcdC8vIFNlbmQgdGhlIHByb21wdCBhcyBhIHBsYWluIHN0cmluZywgbm90IGEgSlNPTiBvYmplY3RcclxuXHRcdFx0Ym9keTogcHJvbXB0LFxyXG5cdFx0fSk7XHJcblxyXG5cdFx0aWYgKCFyZXNwb25zZS5vaykge1xyXG5cdFx0XHQvLyBMb2cgbW9yZSBkZXRhaWxzIGFib3V0IHRoZSBlcnJvclxyXG5cdFx0XHRjb25zdCBlcnJvclRleHQgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XHJcblx0XHRcdGNvbnNvbGUuZXJyb3IoYEltcHJvdmUgcHJvbXB0IEFQSSBlcnJvcjogJHtyZXNwb25zZS5zdGF0dXN9YCwgZXJyb3JUZXh0KTtcclxuXHJcblx0XHRcdC8vIElmIHRoZSBBUEkgZmFpbHMsIHVzZSBvdXIgbG9jYWwgaW1wcm92ZW1lbnQgZnVuY3Rpb25cclxuXHRcdFx0Y29uc29sZS5sb2coXCJVc2luZyBsb2NhbCBwcm9tcHQgaW1wcm92ZW1lbnQgZmFsbGJhY2tcIik7XHJcblx0XHRcdHJldHVybiBsb2NhbEltcHJvdmVQcm9tcHQocHJvbXB0KTtcclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcblxyXG5cdFx0Ly8gSWYgdGhlIEFQSSByZXR1cm5zIHRoZSBzYW1lIHByb21wdCBvciBhbiBlbXB0eSByZXN1bHQsIHVzZSBvdXIgbG9jYWwgaW1wcm92ZW1lbnRcclxuXHRcdGlmIChcclxuXHRcdFx0IXJlc3VsdCB8fFxyXG5cdFx0XHQodHlwZW9mIHJlc3VsdCA9PT0gXCJzdHJpbmdcIiAmJlxyXG5cdFx0XHRcdChyZXN1bHQudHJpbSgpID09PSBwcm9tcHQudHJpbSgpIHx8IHJlc3VsdC50cmltKCkgPT09IFwiXCIpKSB8fFxyXG5cdFx0XHQodHlwZW9mIHJlc3VsdCA9PT0gXCJvYmplY3RcIiAmJlxyXG5cdFx0XHRcdCghcmVzdWx0LlJlc3BvbnNlIHx8IHJlc3VsdC5SZXNwb25zZS50cmltKCkgPT09IHByb21wdC50cmltKCkpKVxyXG5cdFx0KSB7XHJcblx0XHRcdGNvbnNvbGUubG9nKFwiQVBJIHJldHVybmVkIHVuY2hhbmdlZCBwcm9tcHQsIHVzaW5nIGxvY2FsIGltcHJvdmVtZW50XCIpO1xyXG5cdFx0XHRyZXR1cm4gbG9jYWxJbXByb3ZlUHJvbXB0KHByb21wdCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHJlc3VsdDtcclxuXHR9IGNhdGNoIChlcnJvcikge1xyXG5cdFx0Y29uc29sZS5lcnJvcihcIkVycm9yIGltcHJvdmluZyBwcm9tcHQ6XCIsIGVycm9yKTtcclxuXHRcdC8vIFVzZSBsb2NhbCBpbXByb3ZlbWVudCBhcyBmYWxsYmFja1xyXG5cdFx0cmV0dXJuIGxvY2FsSW1wcm92ZVByb21wdChwcm9tcHQpO1xyXG5cdH1cclxufVxyXG4iXSwibmFtZXMiOlsiQVBJX0JBU0VfVVJMIiwiZ2V0TW9kZWxzIiwicmVzcG9uc2UiLCJmZXRjaCIsImhlYWRlcnMiLCJvayIsIkVycm9yIiwic3RhdHVzIiwianNvbiIsImVycm9yIiwiY29uc29sZSIsIm1vZGVscyIsImNoZWNrSGVhbHRoIiwiZ2V0Q2hhdFJlc3BvbnNlIiwicHJvbXB0IiwibW9kZWwiLCJlbmNvZGVVUklDb21wb25lbnQiLCJtZXRob2QiLCJBY2NlcHQiLCJkYXRhIiwibG9jYWxJbXByb3ZlUHJvbXB0IiwiaW1wcm92ZWQiLCJsZW5ndGgiLCJpbmNsdWRlcyIsInNwbGl0IiwiaW1wcm92ZVByb21wdFRleHQiLCJ0YXJnZXQiLCJlcnJvclRleHQiLCJ0ZXh0IiwicmVzdWx0IiwiaW1wcm92ZVByb21wdCIsImJvZHkiLCJsb2ciLCJ0cmltIiwiUmVzcG9uc2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/api.ts\n"));

/***/ })

});