"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/lib/api.ts":
/*!************************!*\
  !*** ./src/lib/api.ts ***!
  \************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   checkHealth: function() { return /* binding */ checkHealth; },\n/* harmony export */   getChatResponse: function() { return /* binding */ getChatResponse; },\n/* harmony export */   getModels: function() { return /* binding */ getModels; },\n/* harmony export */   improvePrompt: function() { return /* binding */ improvePrompt; },\n/* harmony export */   improvePromptText: function() { return /* binding */ improvePromptText; },\n/* harmony export */   localImprovePrompt: function() { return /* binding */ localImprovePrompt; }\n/* harmony export */ });\n// API client for interacting with the AI gateway\n// Base URL for the API\nconst API_BASE_URL = \"https://secret-ai-gateway.onrender.com\";\n// Function to get available models\nasync function getModels() {\n    try {\n        const response = await fetch(\"\".concat(API_BASE_URL, \"/api/models\"));\n        if (!response.ok) {\n            throw new Error(\"Failed to fetch models: \".concat(response.status));\n        }\n        return await response.json();\n    } catch (error) {\n        console.error(\"Error fetching models:\", error);\n        return {\n            models: [\n                \"deepseek-r1:70b\",\n                \"llama3.2-vision\"\n            ]\n        }; // Fallback\n    }\n}\n// Function to check API health\nasync function checkHealth() {\n    try {\n        const response = await fetch(\"\".concat(API_BASE_URL, \"/api/health\"));\n        return response.ok;\n    } catch (error) {\n        console.error(\"Health check failed:\", error);\n        return false;\n    }\n}\n// Function to get chat response\n// Function to get chat response\nasync function getChatResponse(prompt) {\n    let model = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"deepseek-r1:70b\";\n    try {\n        const response = await fetch(\"\".concat(API_BASE_URL, \"/api/chat?prompt=\").concat(encodeURIComponent(prompt), \"&model=\").concat(model), {\n            method: \"GET\",\n            headers: {\n                Accept: \"application/json\",\n                \"X-API-Key\": \"bWFzdGVyQHNjcnRsYWJzLmNvbTpTZWNyZXROZXR3b3JrTWFzdGVyS2V5X18yMDI1\"\n            }\n        });\n        if (!response.ok) {\n            throw new Error(\"Chat API error: \".concat(response.status));\n        }\n        const data = await response.json();\n        return data;\n    } catch (error) {\n        console.error(\"Error getting chat response:\", error);\n        throw error;\n    }\n}\n// Local fallback function to improve prompts if the API fails\nfunction localImprovePrompt(prompt) {\n    // Simple improvements\n    let improved = prompt;\n    // Add specificity\n    if (prompt.length < 20) {\n        improved = \"\".concat(prompt, \" with detailed examples and step-by-step instructions\");\n    }\n    // Add clarity for vague prompts\n    if (!prompt.includes(\"?\") && prompt.split(\" \").length < 5) {\n        improved = \"Please provide a comprehensive explanation about \".concat(prompt);\n    }\n    // Add structure for longer prompts\n    if (prompt.length > 50 && !prompt.includes(\"1.\") && !prompt.includes(\"First\")) {\n        improved = \"\".concat(prompt, \"\\n\\nPlease structure your response with:\\n1. Introduction\\n2. Main points\\n3. Examples\\n4. Conclusion\");\n    }\n    // If we didn't make any improvements, add a generic enhancement\n    if (improved === prompt) {\n        improved = \"\".concat(prompt, \"\\n\\nPlease provide a detailed, well-structured response with examples where appropriate.\");\n    }\n    return improved;\n}\n// Function to improve a prompt using the new GET endpoint\nasync function improvePromptText(prompt) {\n    let target = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"text\";\n    try {\n        const response = await fetch(\"\".concat(API_BASE_URL, \"/api/improve-prompt?prompt=\").concat(encodeURIComponent(prompt), \"&target=\").concat(target), {\n            method: \"GET\",\n            headers: {\n                Accept: \"application/json\"\n            }\n        });\n        if (!response.ok) {\n            const errorText = await response.text();\n            console.error(\"Improve prompt API error: \".concat(response.status), errorText);\n            return localImprovePrompt(prompt);\n        }\n        const result = await response.json();\n        // Handle the response format: { \"response\": \"<improved prompt>\" }\n        if (result && result.response) {\n            return result.response;\n        }\n        // Fallback to local improvement if response format is unexpected\n        return localImprovePrompt(prompt);\n    } catch (error) {\n        console.error(\"Error improving prompt:\", error);\n        return localImprovePrompt(prompt);\n    }\n}\nasync function improvePrompt(prompt) {\n    try {\n        // The API expects a string as the body, not a JSON object\n        const response = await fetch(\"\".concat(API_BASE_URL, \"/api/improve-prompt\"), {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"text/plain\",\n                Accept: \"application/json\"\n            },\n            // Send the prompt as a plain string, not a JSON object\n            body: prompt\n        });\n        if (!response.ok) {\n            // Log more details about the error\n            const errorText = await response.text();\n            console.error(\"Improve prompt API error: \".concat(response.status), errorText);\n            // If the API fails, use our local improvement function\n            console.log(\"Using local prompt improvement fallback\");\n            return localImprovePrompt(prompt);\n        }\n        const result = await response.json();\n        // If the API returns the same prompt or an empty result, use our local improvement\n        if (!result || typeof result === \"string\" && (result.trim() === prompt.trim() || result.trim() === \"\") || typeof result === \"object\" && (!result.Response || result.Response.trim() === prompt.trim())) {\n            console.log(\"API returned unchanged prompt, using local improvement\");\n            return localImprovePrompt(prompt);\n        }\n        return result;\n    } catch (error) {\n        console.error(\"Error improving prompt:\", error);\n        // Use local improvement as fallback\n        return localImprovePrompt(prompt);\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QU9LLFFBQVEsQ0FBQ0QsSUFBSSxPQUFPcEIsT0FBT29CLElBQUksRUFBQyxHQUM1RDtZQUNEeEIsUUFBUXVCLEdBQUcsQ0FBQztZQUNaLE9BQU9aLG1CQUFtQlA7UUFDM0I7UUFFQSxPQUFPZ0I7SUFDUixFQUFFLE9BQU9yQixPQUFPO1FBQ2ZDLFFBQVFELEtBQUssQ0FBQywyQkFBMkJBO1FBQ3pDLG9DQUFvQztRQUNwQyxPQUFPWSxtQkFBbUJQO0lBQzNCO0FBQ0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2xpYi9hcGkudHM/MmZhYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBBUEkgY2xpZW50IGZvciBpbnRlcmFjdGluZyB3aXRoIHRoZSBBSSBnYXRld2F5XHJcblxyXG4vLyBCYXNlIFVSTCBmb3IgdGhlIEFQSVxyXG5jb25zdCBBUElfQkFTRV9VUkwgPSBcImh0dHBzOi8vc2VjcmV0LWFpLWdhdGV3YXkub25yZW5kZXIuY29tXCI7XHJcblxyXG4vLyBBdmFpbGFibGUgbW9kZWxzXHJcbmV4cG9ydCB0eXBlIEFJTW9kZWwgPSBcImRlZXBzZWVrLXIxOjcwYlwiIHwgXCJsbGFtYTMuMi12aXNpb25cIjtcclxuXHJcbi8vIEZ1bmN0aW9uIHRvIGdldCBhdmFpbGFibGUgbW9kZWxzXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRNb2RlbHMoKSB7XHJcblx0dHJ5IHtcclxuXHRcdGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7QVBJX0JBU0VfVVJMfS9hcGkvbW9kZWxzYCk7XHJcblx0XHRpZiAoIXJlc3BvbnNlLm9rKSB7XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGZldGNoIG1vZGVsczogJHtyZXNwb25zZS5zdGF0dXN9YCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG5cdH0gY2F0Y2ggKGVycm9yKSB7XHJcblx0XHRjb25zb2xlLmVycm9yKFwiRXJyb3IgZmV0Y2hpbmcgbW9kZWxzOlwiLCBlcnJvcik7XHJcblx0XHRyZXR1cm4geyBtb2RlbHM6IFtcImRlZXBzZWVrLXIxOjcwYlwiLCBcImxsYW1hMy4yLXZpc2lvblwiXSB9OyAvLyBGYWxsYmFja1xyXG5cdH1cclxufVxyXG5cclxuLy8gRnVuY3Rpb24gdG8gY2hlY2sgQVBJIGhlYWx0aFxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY2hlY2tIZWFsdGgoKSB7XHJcblx0dHJ5IHtcclxuXHRcdGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7QVBJX0JBU0VfVVJMfS9hcGkvaGVhbHRoYCk7XHJcblx0XHRyZXR1cm4gcmVzcG9uc2Uub2s7XHJcblx0fSBjYXRjaCAoZXJyb3IpIHtcclxuXHRcdGNvbnNvbGUuZXJyb3IoXCJIZWFsdGggY2hlY2sgZmFpbGVkOlwiLCBlcnJvcik7XHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblx0fVxyXG59XHJcblxyXG4vLyBGdW5jdGlvbiB0byBnZXQgY2hhdCByZXNwb25zZVxyXG4vLyBGdW5jdGlvbiB0byBnZXQgY2hhdCByZXNwb25zZVxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0Q2hhdFJlc3BvbnNlKFxyXG5cdHByb21wdDogc3RyaW5nLFxyXG5cdG1vZGVsOiBBSU1vZGVsID0gXCJkZWVwc2Vlay1yMTo3MGJcIlxyXG4pIHtcclxuXHR0cnkge1xyXG5cdFx0Y29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChcclxuXHRcdFx0YCR7QVBJX0JBU0VfVVJMfS9hcGkvY2hhdD9wcm9tcHQ9JHtlbmNvZGVVUklDb21wb25lbnQoXHJcblx0XHRcdFx0cHJvbXB0XHJcblx0XHRcdCl9Jm1vZGVsPSR7bW9kZWx9YCxcclxuXHRcdFx0e1xyXG5cdFx0XHRcdG1ldGhvZDogXCJHRVRcIixcclxuXHRcdFx0XHRoZWFkZXJzOiB7XHJcblx0XHRcdFx0XHRBY2NlcHQ6IFwiYXBwbGljYXRpb24vanNvblwiLFxyXG5cdFx0XHRcdFx0XCJYLUFQSS1LZXlcIjogXCJiV0Z6ZEdWeVFITmpjblJzWVdKekxtTnZiVHBUWldOeVpYUk9aWFIzYjNKclRXRnpkR1Z5UzJWNVgxOHlNREkxXCJcclxuXHRcdFx0XHR9LFxyXG5cdFx0XHR9XHJcblx0XHQpO1xyXG5cclxuXHRcdGlmICghcmVzcG9uc2Uub2spIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKGBDaGF0IEFQSSBlcnJvcjogJHtyZXNwb25zZS5zdGF0dXN9YCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Y29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuXHRcdHJldHVybiBkYXRhO1xyXG5cdH0gY2F0Y2ggKGVycm9yKSB7XHJcblx0XHRjb25zb2xlLmVycm9yKFwiRXJyb3IgZ2V0dGluZyBjaGF0IHJlc3BvbnNlOlwiLCBlcnJvcik7XHJcblx0XHR0aHJvdyBlcnJvcjtcclxuXHR9XHJcbn1cclxuXHJcbi8vIExvY2FsIGZhbGxiYWNrIGZ1bmN0aW9uIHRvIGltcHJvdmUgcHJvbXB0cyBpZiB0aGUgQVBJIGZhaWxzXHJcbmV4cG9ydCBmdW5jdGlvbiBsb2NhbEltcHJvdmVQcm9tcHQocHJvbXB0OiBzdHJpbmcpOiBzdHJpbmcge1xyXG5cdC8vIFNpbXBsZSBpbXByb3ZlbWVudHNcclxuXHRsZXQgaW1wcm92ZWQgPSBwcm9tcHQ7XHJcblxyXG5cdC8vIEFkZCBzcGVjaWZpY2l0eVxyXG5cdGlmIChwcm9tcHQubGVuZ3RoIDwgMjApIHtcclxuXHRcdGltcHJvdmVkID0gYCR7cHJvbXB0fSB3aXRoIGRldGFpbGVkIGV4YW1wbGVzIGFuZCBzdGVwLWJ5LXN0ZXAgaW5zdHJ1Y3Rpb25zYDtcclxuXHR9XHJcblxyXG5cdC8vIEFkZCBjbGFyaXR5IGZvciB2YWd1ZSBwcm9tcHRzXHJcblx0aWYgKCFwcm9tcHQuaW5jbHVkZXMoXCI/XCIpICYmIHByb21wdC5zcGxpdChcIiBcIikubGVuZ3RoIDwgNSkge1xyXG5cdFx0aW1wcm92ZWQgPSBgUGxlYXNlIHByb3ZpZGUgYSBjb21wcmVoZW5zaXZlIGV4cGxhbmF0aW9uIGFib3V0ICR7cHJvbXB0fWA7XHJcblx0fVxyXG5cclxuXHQvLyBBZGQgc3RydWN0dXJlIGZvciBsb25nZXIgcHJvbXB0c1xyXG5cdGlmIChcclxuXHRcdHByb21wdC5sZW5ndGggPiA1MCAmJlxyXG5cdFx0IXByb21wdC5pbmNsdWRlcyhcIjEuXCIpICYmXHJcblx0XHQhcHJvbXB0LmluY2x1ZGVzKFwiRmlyc3RcIilcclxuXHQpIHtcclxuXHRcdGltcHJvdmVkID0gYCR7cHJvbXB0fVxcblxcblBsZWFzZSBzdHJ1Y3R1cmUgeW91ciByZXNwb25zZSB3aXRoOlxcbjEuIEludHJvZHVjdGlvblxcbjIuIE1haW4gcG9pbnRzXFxuMy4gRXhhbXBsZXNcXG40LiBDb25jbHVzaW9uYDtcclxuXHR9XHJcblxyXG5cdC8vIElmIHdlIGRpZG4ndCBtYWtlIGFueSBpbXByb3ZlbWVudHMsIGFkZCBhIGdlbmVyaWMgZW5oYW5jZW1lbnRcclxuXHRpZiAoaW1wcm92ZWQgPT09IHByb21wdCkge1xyXG5cdFx0aW1wcm92ZWQgPSBgJHtwcm9tcHR9XFxuXFxuUGxlYXNlIHByb3ZpZGUgYSBkZXRhaWxlZCwgd2VsbC1zdHJ1Y3R1cmVkIHJlc3BvbnNlIHdpdGggZXhhbXBsZXMgd2hlcmUgYXBwcm9wcmlhdGUuYDtcclxuXHR9XHJcblxyXG5cdHJldHVybiBpbXByb3ZlZDtcclxufVxyXG5cclxuLy8gRnVuY3Rpb24gdG8gaW1wcm92ZSBhIHByb21wdCB1c2luZyB0aGUgbmV3IEdFVCBlbmRwb2ludFxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gaW1wcm92ZVByb21wdFRleHQocHJvbXB0OiBzdHJpbmcsIHRhcmdldDogJ3RleHQnIHwgJ2ltYWdlJyA9ICd0ZXh0Jykge1xyXG5cdHRyeSB7XHJcblx0XHRjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKFxyXG5cdFx0XHRgJHtBUElfQkFTRV9VUkx9L2FwaS9pbXByb3ZlLXByb21wdD9wcm9tcHQ9JHtlbmNvZGVVUklDb21wb25lbnQocHJvbXB0KX0mdGFyZ2V0PSR7dGFyZ2V0fWAsXHJcblx0XHRcdHtcclxuXHRcdFx0XHRtZXRob2Q6IFwiR0VUXCIsXHJcblx0XHRcdFx0aGVhZGVyczoge1xyXG5cdFx0XHRcdFx0QWNjZXB0OiBcImFwcGxpY2F0aW9uL2pzb25cIixcclxuXHRcdFx0XHR9LFxyXG5cdFx0XHR9XHJcblx0XHQpO1xyXG5cclxuXHRcdGlmICghcmVzcG9uc2Uub2spIHtcclxuXHRcdFx0Y29uc3QgZXJyb3JUZXh0ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xyXG5cdFx0XHRjb25zb2xlLmVycm9yKGBJbXByb3ZlIHByb21wdCBBUEkgZXJyb3I6ICR7cmVzcG9uc2Uuc3RhdHVzfWAsIGVycm9yVGV4dCk7XHJcblx0XHRcdHJldHVybiBsb2NhbEltcHJvdmVQcm9tcHQocHJvbXB0KTtcclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcblx0XHRcclxuXHRcdC8vIEhhbmRsZSB0aGUgcmVzcG9uc2UgZm9ybWF0OiB7IFwicmVzcG9uc2VcIjogXCI8aW1wcm92ZWQgcHJvbXB0PlwiIH1cclxuXHRcdGlmIChyZXN1bHQgJiYgcmVzdWx0LnJlc3BvbnNlKSB7XHJcblx0XHRcdHJldHVybiByZXN1bHQucmVzcG9uc2U7XHJcblx0XHR9XHJcblx0XHRcclxuXHRcdC8vIEZhbGxiYWNrIHRvIGxvY2FsIGltcHJvdmVtZW50IGlmIHJlc3BvbnNlIGZvcm1hdCBpcyB1bmV4cGVjdGVkXHJcblx0XHRyZXR1cm4gbG9jYWxJbXByb3ZlUHJvbXB0KHByb21wdCk7XHJcblx0fSBjYXRjaCAoZXJyb3IpIHtcclxuXHRcdGNvbnNvbGUuZXJyb3IoXCJFcnJvciBpbXByb3ZpbmcgcHJvbXB0OlwiLCBlcnJvcik7XHJcblx0XHRyZXR1cm4gbG9jYWxJbXByb3ZlUHJvbXB0KHByb21wdCk7XHJcblx0fVxyXG59XHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBpbXByb3ZlUHJvbXB0KHByb21wdDogc3RyaW5nKSB7XHJcblx0dHJ5IHtcclxuXHRcdC8vIFRoZSBBUEkgZXhwZWN0cyBhIHN0cmluZyBhcyB0aGUgYm9keSwgbm90IGEgSlNPTiBvYmplY3RcclxuXHRcdGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7QVBJX0JBU0VfVVJMfS9hcGkvaW1wcm92ZS1wcm9tcHRgLCB7XHJcblx0XHRcdG1ldGhvZDogXCJQT1NUXCIsXHJcblx0XHRcdGhlYWRlcnM6IHtcclxuXHRcdFx0XHRcIkNvbnRlbnQtVHlwZVwiOiBcInRleHQvcGxhaW5cIiwgLy8gQ2hhbmdlZCBmcm9tIGFwcGxpY2F0aW9uL2pzb25cclxuXHRcdFx0XHRBY2NlcHQ6IFwiYXBwbGljYXRpb24vanNvblwiLFxyXG5cdFx0XHR9LFxyXG5cdFx0XHQvLyBTZW5kIHRoZSBwcm9tcHQgYXMgYSBwbGFpbiBzdHJpbmcsIG5vdCBhIEpTT04gb2JqZWN0XHJcblx0XHRcdGJvZHk6IHByb21wdCxcclxuXHRcdH0pO1xyXG5cclxuXHRcdGlmICghcmVzcG9uc2Uub2spIHtcclxuXHRcdFx0Ly8gTG9nIG1vcmUgZGV0YWlscyBhYm91dCB0aGUgZXJyb3JcclxuXHRcdFx0Y29uc3QgZXJyb3JUZXh0ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xyXG5cdFx0XHRjb25zb2xlLmVycm9yKGBJbXByb3ZlIHByb21wdCBBUEkgZXJyb3I6ICR7cmVzcG9uc2Uuc3RhdHVzfWAsIGVycm9yVGV4dCk7XHJcblxyXG5cdFx0XHQvLyBJZiB0aGUgQVBJIGZhaWxzLCB1c2Ugb3VyIGxvY2FsIGltcHJvdmVtZW50IGZ1bmN0aW9uXHJcblx0XHRcdGNvbnNvbGUubG9nKFwiVXNpbmcgbG9jYWwgcHJvbXB0IGltcHJvdmVtZW50IGZhbGxiYWNrXCIpO1xyXG5cdFx0XHRyZXR1cm4gbG9jYWxJbXByb3ZlUHJvbXB0KHByb21wdCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Y29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG5cclxuXHRcdC8vIElmIHRoZSBBUEkgcmV0dXJucyB0aGUgc2FtZSBwcm9tcHQgb3IgYW4gZW1wdHkgcmVzdWx0LCB1c2Ugb3VyIGxvY2FsIGltcHJvdmVtZW50XHJcblx0XHRpZiAoXHJcblx0XHRcdCFyZXN1bHQgfHxcclxuXHRcdFx0KHR5cGVvZiByZXN1bHQgPT09IFwic3RyaW5nXCIgJiZcclxuXHRcdFx0XHQocmVzdWx0LnRyaW0oKSA9PT0gcHJvbXB0LnRyaW0oKSB8fCByZXN1bHQudHJpbSgpID09PSBcIlwiKSkgfHxcclxuXHRcdFx0KHR5cGVvZiByZXN1bHQgPT09IFwib2JqZWN0XCIgJiZcclxuXHRcdFx0XHQoIXJlc3VsdC5SZXNwb25zZSB8fCByZXN1bHQuUmVzcG9uc2UudHJpbSgpID09PSBwcm9tcHQudHJpbSgpKSlcclxuXHRcdCkge1xyXG5cdFx0XHRjb25zb2xlLmxvZyhcIkFQSSByZXR1cm5lZCB1bmNoYW5nZWQgcHJvbXB0LCB1c2luZyBsb2NhbCBpbXByb3ZlbWVudFwiKTtcclxuXHRcdFx0cmV0dXJuIGxvY2FsSW1wcm92ZVByb21wdChwcm9tcHQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiByZXN1bHQ7XHJcblx0fSBjYXRjaCAoZXJyb3IpIHtcclxuXHRcdGNvbnNvbGUuZXJyb3IoXCJFcnJvciBpbXByb3ZpbmcgcHJvbXB0OlwiLCBlcnJvcik7XHJcblx0XHQvLyBVc2UgbG9jYWwgaW1wcm92ZW1lbnQgYXMgZmFsbGJhY2tcclxuXHRcdHJldHVybiBsb2NhbEltcHJvdmVQcm9tcHQocHJvbXB0KTtcclxuXHR9XHJcbn1cclxuIl0sIm5hbWVzIjpbIkFQSV9CQVNFX1VSTCIsImdldE1vZGVscyIsInJlc3BvbnNlIiwiZmV0Y2giLCJvayIsIkVycm9yIiwic3RhdHVzIiwianNvbiIsImVycm9yIiwiY29uc29sZSIsIm1vZGVscyIsImNoZWNrSGVhbHRoIiwiZ2V0Q2hhdFJlc3BvbnNlIiwicHJvbXB0IiwibW9kZWwiLCJlbmNvZGVVUklDb21wb25lbnQiLCJtZXRob2QiLCJoZWFkZXJzIiwiQWNjZXB0IiwiZGF0YSIsImxvY2FsSW1wcm92ZVByb21wdCIsImltcHJvdmVkIiwibGVuZ3RoIiwiaW5jbHVkZXMiLCJzcGxpdCIsImltcHJvdmVQcm9tcHRUZXh0IiwidGFyZ2V0IiwiZXJyb3JUZXh0IiwidGV4dCIsInJlc3VsdCIsImltcHJvdmVQcm9tcHQiLCJib2R5IiwibG9nIiwidHJpbSIsIlJlc3BvbnNlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/api.ts\n"));

/***/ })

});