"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/sell/page",{

/***/ "(app-pages-browser)/./src/lib/api.ts":
/*!************************!*\
  !*** ./src/lib/api.ts ***!
  \************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   checkHealth: function() { return /* binding */ checkHealth; },\n/* harmony export */   getChatResponse: function() { return /* binding */ getChatResponse; },\n/* harmony export */   getModels: function() { return /* binding */ getModels; },\n/* harmony export */   improvePrompt: function() { return /* binding */ improvePrompt; },\n/* harmony export */   improvePromptText: function() { return /* binding */ improvePromptText; },\n/* harmony export */   localImprovePrompt: function() { return /* binding */ localImprovePrompt; }\n/* harmony export */ });\n// API client for interacting with the AI gateway\n// Base URL for the API\nconst API_BASE_URL = \"https://secret-ai-gateway.onrender.com\";\n// Function to get available models\nasync function getModels() {\n    try {\n        const response = await fetch(\"\".concat(API_BASE_URL, \"/api/models\"), {\n            headers: {\n                \"X-API-Key\": \"bWFzdGVyQHNjcnRsYWJzLmNvbTpTZWNyZXROZXR3b3JrTWFzdGVyS2V5X18yMDI1\"\n            }\n        });\n        if (!response.ok) {\n            throw new Error(\"Failed to fetch models: \".concat(response.status));\n        }\n        return await response.json();\n    } catch (error) {\n        console.error(\"Error fetching models:\", error);\n        return {\n            models: [\n                \"deepseek-r1:70b\",\n                \"llama3.2-vision\"\n            ]\n        }; // Fallback\n    }\n}\n// Function to check API health\nasync function checkHealth() {\n    try {\n        const response = await fetch(\"\".concat(API_BASE_URL, \"/api/health\"), {\n            headers: {\n                \"X-API-Key\": \"bWFzdGVyQHNjcnRsYWJzLmNvbTpTZWNyZXROZXR3b3JrTWFzdGVyS2V5X18yMDI1\"\n            }\n        });\n        return response.ok;\n    } catch (error) {\n        console.error(\"Health check failed:\", error);\n        return false;\n    }\n}\n// Function to get chat response\nasync function getChatResponse(prompt) {\n    let model = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"deepseek-r1:70b\";\n    try {\n        // Use the same format as your working test\n        const response = await fetch(\"\".concat(API_BASE_URL, \"/api/chat?prompt=\").concat(encodeURIComponent(prompt), \"&model=\").concat(model), {\n            method: \"GET\",\n            headers: {\n                Accept: \"application/json\"\n            }\n        });\n        if (!response.ok) {\n            const errorText = await response.text();\n            console.error(\"Chat API error: \".concat(response.status), errorText);\n            throw new Error(\"Chat API error: \".concat(response.status));\n        }\n        const data = await response.json();\n        return data;\n    } catch (error) {\n        console.error(\"Error getting chat response:\", error);\n        throw error;\n    }\n}\n// Local fallback function to improve prompts if the API fails\nfunction localImprovePrompt(prompt) {\n    // Simple improvements\n    let improved = prompt;\n    // Add specificity\n    if (prompt.length < 20) {\n        improved = \"\".concat(prompt, \" with detailed examples and step-by-step instructions\");\n    }\n    // Add clarity for vague prompts\n    if (!prompt.includes(\"?\") && prompt.split(\" \").length < 5) {\n        improved = \"Please provide a comprehensive explanation about \".concat(prompt);\n    }\n    // Add structure for longer prompts\n    if (prompt.length > 50 && !prompt.includes(\"1.\") && !prompt.includes(\"First\")) {\n        improved = \"\".concat(prompt, \"\\n\\nPlease structure your response with:\\n1. Introduction\\n2. Main points\\n3. Examples\\n4. Conclusion\");\n    }\n    // If we didn't make any improvements, add a generic enhancement\n    if (improved === prompt) {\n        improved = \"\".concat(prompt, \"\\n\\nPlease provide a detailed, well-structured response with examples where appropriate.\");\n    }\n    return improved;\n}\n// Function to improve a prompt using the new GET endpoint\nasync function improvePromptText(prompt) {\n    let target = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"text\";\n    try {\n        const response = await fetch(\"\".concat(API_BASE_URL, \"/api/improve-prompt?prompt=\").concat(encodeURIComponent(prompt), \"&target=\").concat(target), {\n            method: \"GET\",\n            headers: {\n                Accept: \"application/json\"\n            }\n        });\n        if (!response.ok) {\n            const errorText = await response.text();\n            console.error(\"Improve prompt API error: \".concat(response.status), errorText);\n            return localImprovePrompt(prompt);\n        }\n        const result = await response.json();\n        // Handle the response format: { \"response\": \"<improved prompt>\" }\n        if (result && result.response) {\n            return result.response;\n        }\n        // Fallback to local improvement if response format is unexpected\n        return localImprovePrompt(prompt);\n    } catch (error) {\n        console.error(\"Error improving prompt:\", error);\n        return localImprovePrompt(prompt);\n    }\n}\nasync function improvePrompt(prompt) {\n    try {\n        // The API expects a string as the body, not a JSON object\n        const response = await fetch(\"\".concat(API_BASE_URL, \"/api/improve-prompt\"), {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"text/plain\",\n                Accept: \"application/json\"\n            },\n            // Send the prompt as a plain string, not a JSON object\n            body: prompt\n        });\n        if (!response.ok) {\n            // Log more details about the error\n            const errorText = await response.text();\n            console.error(\"Improve prompt API error: \".concat(response.status), errorText);\n            // If the API fails, use our local improvement function\n            console.log(\"Using local prompt improvement fallback\");\n            return localImprovePrompt(prompt);\n        }\n        const result = await response.json();\n        // If the API returns the same prompt or an empty result, use our local improvement\n        if (!result || typeof result === \"string\" && (result.trim() === prompt.trim() || result.trim() === \"\") || typeof result === \"object\" && (!result.Response || result.Response.trim() === prompt.trim())) {\n            console.log(\"API returned unchanged prompt, using local improvement\");\n            return localImprovePrompt(prompt);\n        }\n        return result;\n    } catch (error) {\n        console.error(\"Error improving prompt:\", error);\n        // Use local improvement as fallback\n        return localImprovePrompt(prompt);\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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RixJQUNDLENBQUNxQixVQUNBLE9BQU9BLFdBQVcsWUFDakJBLENBQUFBLE9BQU9JLElBQUksT0FBT25CLE9BQU9tQixJQUFJLE1BQU1KLE9BQU9JLElBQUksT0FBTyxFQUFDLEtBQ3ZELE9BQU9KLFdBQVcsWUFDakIsRUFBQ0EsT0FBT0ssUUFBUSxJQUFJTCxPQUFPSyxRQUFRLENBQUNELElBQUksT0FBT25CLE9BQU9tQixJQUFJLEVBQUMsR0FDNUQ7WUFDRHZCLFFBQVFzQixHQUFHLENBQUM7WUFDWixPQUFPVixtQkFBbUJSO1FBQzNCO1FBRUEsT0FBT2U7SUFDUixFQUFFLE9BQU9wQixPQUFPO1FBQ2ZDLFFBQVFELEtBQUssQ0FBQywyQkFBMkJBO1FBQ3pDLG9DQUFvQztRQUNwQyxPQUFPYSxtQkFBbUJSO0lBQzNCO0FBQ0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2xpYi9hcGkudHM/MmZhYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBBUEkgY2xpZW50IGZvciBpbnRlcmFjdGluZyB3aXRoIHRoZSBBSSBnYXRld2F5XHJcblxyXG4vLyBCYXNlIFVSTCBmb3IgdGhlIEFQSVxyXG5jb25zdCBBUElfQkFTRV9VUkwgPSBcImh0dHBzOi8vc2VjcmV0LWFpLWdhdGV3YXkub25yZW5kZXIuY29tXCI7XHJcblxyXG4vLyBBdmFpbGFibGUgbW9kZWxzXHJcbmV4cG9ydCB0eXBlIEFJTW9kZWwgPSBcImRlZXBzZWVrLXIxOjcwYlwiIHwgXCJsbGFtYTMuMi12aXNpb25cIiB8IFwiZ2VtaW5pLTIuNS1mbGFzaFwiO1xyXG5cclxuLy8gRnVuY3Rpb24gdG8gZ2V0IGF2YWlsYWJsZSBtb2RlbHNcclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldE1vZGVscygpIHtcclxuXHR0cnkge1xyXG5cdFx0Y29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtBUElfQkFTRV9VUkx9L2FwaS9tb2RlbHNgLCB7XHJcblx0XHRcdGhlYWRlcnM6IHtcclxuXHRcdFx0XHRcIlgtQVBJLUtleVwiOiBcImJXRnpkR1Z5UUhOamNuUnNZV0p6TG1OdmJUcFRaV055WlhST1pYUjNiM0pyVFdGemRHVnlTMlY1WDE4eU1ESTFcIlxyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHRcdGlmICghcmVzcG9uc2Uub2spIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZmV0Y2ggbW9kZWxzOiAke3Jlc3BvbnNlLnN0YXR1c31gKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcblx0fSBjYXRjaCAoZXJyb3IpIHtcclxuXHRcdGNvbnNvbGUuZXJyb3IoXCJFcnJvciBmZXRjaGluZyBtb2RlbHM6XCIsIGVycm9yKTtcclxuXHRcdHJldHVybiB7IG1vZGVsczogW1wiZGVlcHNlZWstcjE6NzBiXCIsIFwibGxhbWEzLjItdmlzaW9uXCJdIH07IC8vIEZhbGxiYWNrXHJcblx0fVxyXG59XHJcblxyXG4vLyBGdW5jdGlvbiB0byBjaGVjayBBUEkgaGVhbHRoXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjaGVja0hlYWx0aCgpIHtcclxuXHR0cnkge1xyXG5cdFx0Y29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtBUElfQkFTRV9VUkx9L2FwaS9oZWFsdGhgLCB7XHJcblx0XHRcdGhlYWRlcnM6IHtcclxuXHRcdFx0XHRcIlgtQVBJLUtleVwiOiBcImJXRnpkR1Z5UUhOamNuUnNZV0p6TG1OdmJUcFRaV055WlhST1pYUjNiM0pyVFdGemRHVnlTMlY1WDE4eU1ESTFcIlxyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHRcdHJldHVybiByZXNwb25zZS5vaztcclxuXHR9IGNhdGNoIChlcnJvcikge1xyXG5cdFx0Y29uc29sZS5lcnJvcihcIkhlYWx0aCBjaGVjayBmYWlsZWQ6XCIsIGVycm9yKTtcclxuXHRcdHJldHVybiBmYWxzZTtcclxuXHR9XHJcbn1cclxuXHJcbi8vIEZ1bmN0aW9uIHRvIGdldCBjaGF0IHJlc3BvbnNlXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRDaGF0UmVzcG9uc2UoXHJcblx0cHJvbXB0OiBzdHJpbmcsXHJcblx0bW9kZWw6IEFJTW9kZWwgPSBcImRlZXBzZWVrLXIxOjcwYlwiXHJcbikge1xyXG5cdHRyeSB7XHJcblx0XHQvLyBVc2UgdGhlIHNhbWUgZm9ybWF0IGFzIHlvdXIgd29ya2luZyB0ZXN0XHJcblx0XHRjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKFxyXG5cdFx0XHRgJHtBUElfQkFTRV9VUkx9L2FwaS9jaGF0P3Byb21wdD0ke2VuY29kZVVSSUNvbXBvbmVudChcclxuXHRcdFx0XHRwcm9tcHRcclxuXHRcdFx0KX0mbW9kZWw9JHttb2RlbH1gLFxyXG5cdFx0XHR7XHJcblx0XHRcdFx0bWV0aG9kOiBcIkdFVFwiLFxyXG5cdFx0XHRcdGhlYWRlcnM6IHtcclxuXHRcdFx0XHRcdEFjY2VwdDogXCJhcHBsaWNhdGlvbi9qc29uXCIsXHJcblx0XHRcdFx0XHQvLyBSZW1vdmUgdGhlIFgtQVBJLUtleSBoZWFkZXIgc2luY2UgeW91ciBkaXJlY3QgdGVzdCB3b3JrcyB3aXRob3V0IGl0XHJcblx0XHRcdFx0fSxcclxuXHRcdFx0fVxyXG5cdFx0KTtcclxuXHJcblx0XHRpZiAoIXJlc3BvbnNlLm9rKSB7XHJcblx0XHRcdGNvbnN0IGVycm9yVGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcclxuXHRcdFx0Y29uc29sZS5lcnJvcihgQ2hhdCBBUEkgZXJyb3I6ICR7cmVzcG9uc2Uuc3RhdHVzfWAsIGVycm9yVGV4dCk7XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcihgQ2hhdCBBUEkgZXJyb3I6ICR7cmVzcG9uc2Uuc3RhdHVzfWApO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcblx0XHRyZXR1cm4gZGF0YTtcclxuXHR9IGNhdGNoIChlcnJvcikge1xyXG5cdFx0Y29uc29sZS5lcnJvcihcIkVycm9yIGdldHRpbmcgY2hhdCByZXNwb25zZTpcIiwgZXJyb3IpO1xyXG5cdFx0dGhyb3cgZXJyb3I7XHJcblx0fVxyXG59XHJcblxyXG4vLyBMb2NhbCBmYWxsYmFjayBmdW5jdGlvbiB0byBpbXByb3ZlIHByb21wdHMgaWYgdGhlIEFQSSBmYWlsc1xyXG5leHBvcnQgZnVuY3Rpb24gbG9jYWxJbXByb3ZlUHJvbXB0KHByb21wdDogc3RyaW5nKTogc3RyaW5nIHtcclxuXHQvLyBTaW1wbGUgaW1wcm92ZW1lbnRzXHJcblx0bGV0IGltcHJvdmVkID0gcHJvbXB0O1xyXG5cclxuXHQvLyBBZGQgc3BlY2lmaWNpdHlcclxuXHRpZiAocHJvbXB0Lmxlbmd0aCA8IDIwKSB7XHJcblx0XHRpbXByb3ZlZCA9IGAke3Byb21wdH0gd2l0aCBkZXRhaWxlZCBleGFtcGxlcyBhbmQgc3RlcC1ieS1zdGVwIGluc3RydWN0aW9uc2A7XHJcblx0fVxyXG5cclxuXHQvLyBBZGQgY2xhcml0eSBmb3IgdmFndWUgcHJvbXB0c1xyXG5cdGlmICghcHJvbXB0LmluY2x1ZGVzKFwiP1wiKSAmJiBwcm9tcHQuc3BsaXQoXCIgXCIpLmxlbmd0aCA8IDUpIHtcclxuXHRcdGltcHJvdmVkID0gYFBsZWFzZSBwcm92aWRlIGEgY29tcHJlaGVuc2l2ZSBleHBsYW5hdGlvbiBhYm91dCAke3Byb21wdH1gO1xyXG5cdH1cclxuXHJcblx0Ly8gQWRkIHN0cnVjdHVyZSBmb3IgbG9uZ2VyIHByb21wdHNcclxuXHRpZiAoXHJcblx0XHRwcm9tcHQubGVuZ3RoID4gNTAgJiZcclxuXHRcdCFwcm9tcHQuaW5jbHVkZXMoXCIxLlwiKSAmJlxyXG5cdFx0IXByb21wdC5pbmNsdWRlcyhcIkZpcnN0XCIpXHJcblx0KSB7XHJcblx0XHRpbXByb3ZlZCA9IGAke3Byb21wdH1cXG5cXG5QbGVhc2Ugc3RydWN0dXJlIHlvdXIgcmVzcG9uc2Ugd2l0aDpcXG4xLiBJbnRyb2R1Y3Rpb25cXG4yLiBNYWluIHBvaW50c1xcbjMuIEV4YW1wbGVzXFxuNC4gQ29uY2x1c2lvbmA7XHJcblx0fVxyXG5cclxuXHQvLyBJZiB3ZSBkaWRuJ3QgbWFrZSBhbnkgaW1wcm92ZW1lbnRzLCBhZGQgYSBnZW5lcmljIGVuaGFuY2VtZW50XHJcblx0aWYgKGltcHJvdmVkID09PSBwcm9tcHQpIHtcclxuXHRcdGltcHJvdmVkID0gYCR7cHJvbXB0fVxcblxcblBsZWFzZSBwcm92aWRlIGEgZGV0YWlsZWQsIHdlbGwtc3RydWN0dXJlZCByZXNwb25zZSB3aXRoIGV4YW1wbGVzIHdoZXJlIGFwcHJvcHJpYXRlLmA7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gaW1wcm92ZWQ7XHJcbn1cclxuXHJcbi8vIEZ1bmN0aW9uIHRvIGltcHJvdmUgYSBwcm9tcHQgdXNpbmcgdGhlIG5ldyBHRVQgZW5kcG9pbnRcclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGltcHJvdmVQcm9tcHRUZXh0KHByb21wdDogc3RyaW5nLCB0YXJnZXQ6ICd0ZXh0JyB8ICdpbWFnZScgPSAndGV4dCcpIHtcclxuXHR0cnkge1xyXG5cdFx0Y29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChcclxuXHRcdFx0YCR7QVBJX0JBU0VfVVJMfS9hcGkvaW1wcm92ZS1wcm9tcHQ/cHJvbXB0PSR7ZW5jb2RlVVJJQ29tcG9uZW50KHByb21wdCl9JnRhcmdldD0ke3RhcmdldH1gLFxyXG5cdFx0XHR7XHJcblx0XHRcdFx0bWV0aG9kOiBcIkdFVFwiLFxyXG5cdFx0XHRcdGhlYWRlcnM6IHtcclxuXHRcdFx0XHRcdEFjY2VwdDogXCJhcHBsaWNhdGlvbi9qc29uXCIsXHJcblx0XHRcdFx0fSxcclxuXHRcdFx0fVxyXG5cdFx0KTtcclxuXHJcblx0XHRpZiAoIXJlc3BvbnNlLm9rKSB7XHJcblx0XHRcdGNvbnN0IGVycm9yVGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcclxuXHRcdFx0Y29uc29sZS5lcnJvcihgSW1wcm92ZSBwcm9tcHQgQVBJIGVycm9yOiAke3Jlc3BvbnNlLnN0YXR1c31gLCBlcnJvclRleHQpO1xyXG5cdFx0XHRyZXR1cm4gbG9jYWxJbXByb3ZlUHJvbXB0KHByb21wdCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Y29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG5cdFx0XHJcblx0XHQvLyBIYW5kbGUgdGhlIHJlc3BvbnNlIGZvcm1hdDogeyBcInJlc3BvbnNlXCI6IFwiPGltcHJvdmVkIHByb21wdD5cIiB9XHJcblx0XHRpZiAocmVzdWx0ICYmIHJlc3VsdC5yZXNwb25zZSkge1xyXG5cdFx0XHRyZXR1cm4gcmVzdWx0LnJlc3BvbnNlO1xyXG5cdFx0fVxyXG5cdFx0XHJcblx0XHQvLyBGYWxsYmFjayB0byBsb2NhbCBpbXByb3ZlbWVudCBpZiByZXNwb25zZSBmb3JtYXQgaXMgdW5leHBlY3RlZFxyXG5cdFx0cmV0dXJuIGxvY2FsSW1wcm92ZVByb21wdChwcm9tcHQpO1xyXG5cdH0gY2F0Y2ggKGVycm9yKSB7XHJcblx0XHRjb25zb2xlLmVycm9yKFwiRXJyb3IgaW1wcm92aW5nIHByb21wdDpcIiwgZXJyb3IpO1xyXG5cdFx0cmV0dXJuIGxvY2FsSW1wcm92ZVByb21wdChwcm9tcHQpO1xyXG5cdH1cclxufVxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gaW1wcm92ZVByb21wdChwcm9tcHQ6IHN0cmluZykge1xyXG5cdHRyeSB7XHJcblx0XHQvLyBUaGUgQVBJIGV4cGVjdHMgYSBzdHJpbmcgYXMgdGhlIGJvZHksIG5vdCBhIEpTT04gb2JqZWN0XHJcblx0XHRjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke0FQSV9CQVNFX1VSTH0vYXBpL2ltcHJvdmUtcHJvbXB0YCwge1xyXG5cdFx0XHRtZXRob2Q6IFwiUE9TVFwiLFxyXG5cdFx0XHRoZWFkZXJzOiB7XHJcblx0XHRcdFx0XCJDb250ZW50LVR5cGVcIjogXCJ0ZXh0L3BsYWluXCIsIC8vIENoYW5nZWQgZnJvbSBhcHBsaWNhdGlvbi9qc29uXHJcblx0XHRcdFx0QWNjZXB0OiBcImFwcGxpY2F0aW9uL2pzb25cIixcclxuXHRcdFx0fSxcclxuXHRcdFx0Ly8gU2VuZCB0aGUgcHJvbXB0IGFzIGEgcGxhaW4gc3RyaW5nLCBub3QgYSBKU09OIG9iamVjdFxyXG5cdFx0XHRib2R5OiBwcm9tcHQsXHJcblx0XHR9KTtcclxuXHJcblx0XHRpZiAoIXJlc3BvbnNlLm9rKSB7XHJcblx0XHRcdC8vIExvZyBtb3JlIGRldGFpbHMgYWJvdXQgdGhlIGVycm9yXHJcblx0XHRcdGNvbnN0IGVycm9yVGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcclxuXHRcdFx0Y29uc29sZS5lcnJvcihgSW1wcm92ZSBwcm9tcHQgQVBJIGVycm9yOiAke3Jlc3BvbnNlLnN0YXR1c31gLCBlcnJvclRleHQpO1xyXG5cclxuXHRcdFx0Ly8gSWYgdGhlIEFQSSBmYWlscywgdXNlIG91ciBsb2NhbCBpbXByb3ZlbWVudCBmdW5jdGlvblxyXG5cdFx0XHRjb25zb2xlLmxvZyhcIlVzaW5nIGxvY2FsIHByb21wdCBpbXByb3ZlbWVudCBmYWxsYmFja1wiKTtcclxuXHRcdFx0cmV0dXJuIGxvY2FsSW1wcm92ZVByb21wdChwcm9tcHQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuXHJcblx0XHQvLyBJZiB0aGUgQVBJIHJldHVybnMgdGhlIHNhbWUgcHJvbXB0IG9yIGFuIGVtcHR5IHJlc3VsdCwgdXNlIG91ciBsb2NhbCBpbXByb3ZlbWVudFxyXG5cdFx0aWYgKFxyXG5cdFx0XHQhcmVzdWx0IHx8XHJcblx0XHRcdCh0eXBlb2YgcmVzdWx0ID09PSBcInN0cmluZ1wiICYmXHJcblx0XHRcdFx0KHJlc3VsdC50cmltKCkgPT09IHByb21wdC50cmltKCkgfHwgcmVzdWx0LnRyaW0oKSA9PT0gXCJcIikpIHx8XHJcblx0XHRcdCh0eXBlb2YgcmVzdWx0ID09PSBcIm9iamVjdFwiICYmXHJcblx0XHRcdFx0KCFyZXN1bHQuUmVzcG9uc2UgfHwgcmVzdWx0LlJlc3BvbnNlLnRyaW0oKSA9PT0gcHJvbXB0LnRyaW0oKSkpXHJcblx0XHQpIHtcclxuXHRcdFx0Y29uc29sZS5sb2coXCJBUEkgcmV0dXJuZWQgdW5jaGFuZ2VkIHByb21wdCwgdXNpbmcgbG9jYWwgaW1wcm92ZW1lbnRcIik7XHJcblx0XHRcdHJldHVybiBsb2NhbEltcHJvdmVQcm9tcHQocHJvbXB0KTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gcmVzdWx0O1xyXG5cdH0gY2F0Y2ggKGVycm9yKSB7XHJcblx0XHRjb25zb2xlLmVycm9yKFwiRXJyb3IgaW1wcm92aW5nIHByb21wdDpcIiwgZXJyb3IpO1xyXG5cdFx0Ly8gVXNlIGxvY2FsIGltcHJvdmVtZW50IGFzIGZhbGxiYWNrXHJcblx0XHRyZXR1cm4gbG9jYWxJbXByb3ZlUHJvbXB0KHByb21wdCk7XHJcblx0fVxyXG59XHJcbiJdLCJuYW1lcyI6WyJBUElfQkFTRV9VUkwiLCJnZXRNb2RlbHMiLCJyZXNwb25zZSIsImZldGNoIiwiaGVhZGVycyIsIm9rIiwiRXJyb3IiLCJzdGF0dXMiLCJqc29uIiwiZXJyb3IiLCJjb25zb2xlIiwibW9kZWxzIiwiY2hlY2tIZWFsdGgiLCJnZXRDaGF0UmVzcG9uc2UiLCJwcm9tcHQiLCJtb2RlbCIsImVuY29kZVVSSUNvbXBvbmVudCIsIm1ldGhvZCIsIkFjY2VwdCIsImVycm9yVGV4dCIsInRleHQiLCJkYXRhIiwibG9jYWxJbXByb3ZlUHJvbXB0IiwiaW1wcm92ZWQiLCJsZW5ndGgiLCJpbmNsdWRlcyIsInNwbGl0IiwiaW1wcm92ZVByb21wdFRleHQiLCJ0YXJnZXQiLCJyZXN1bHQiLCJpbXByb3ZlUHJvbXB0IiwiYm9keSIsImxvZyIsInRyaW0iLCJSZXNwb25zZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/api.ts\n"));

/***/ })

});